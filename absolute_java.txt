Overloading
	- Two or more methods in the same class can have the same method name.
	Rules for overloading:
		* Two definitions of the method name either must have different numbers
			of parameters or some parameter position must be of differing 
			types in the two definitions. 


	+ Example:
		public void setDate(int month, int day, int year);
		public void setDate(String month, int day, int year);
		public void setDate(int year)
	- PITFALL: Overloading and automatic type conversion:
		+ Example:
			public void increase(double factor)
			{
				year = (int)(year + factor*year);
			}

			public void increase(int term)
			{
				year = int(year + term);
			}

			=> date.incresese(2) // maybe not what you want

			public void doSth(double n1, int n2)
			public void doSth(int n1, double n2)

			=> doSth(3,5) => error
	Note: 	+ Java always looks for a overloading method before it tries to use automatic
		type conversion.
		+ Cannot overload based on the type returned.
		{
			public int computeSth(int n);
			public double computeSth(int n);
		=> illegal
		}
		+ Cannot overload operators in Java (+/-)
	
Constructors
	Use overloading to define multiple constructors.
	+ Example:
		public class Date{
			private int year;

			public Date()
			{
				year = 1000;
			}
			

			public Date(Date aDate)
			{
				if(aDate == null)
				{
					System.out.println("Fatal error");
					System.exit(0);
				}
				year = aDate.year;
			}

		}
		
		=> Date nowYear = new Date(2090);
	
	Default variable initializations
	Note:  + Local variables are not automatically initialized in Java, so you must
		initialize a local variable before using it.
	       + Instance variables are automatically initialized.
	       + Constructors normally set all instance variables, even if there is not a
		full set of parameter.

	The StringTokenizer Class
	TSC is used to recover the words in a multiword string.
		Example:
			StringTokenizer wordFactory = new StringTokenizer("Hello World");
			while (wordFactory.hasMoreTokens())
			{
				System.out.println(wordFactory.nextToken());
			}
			=> Output:
				Hello
				World
			Similar like split: new StringTokenizer(String, delimit: " \n.,");
	
	Compare 2 string: str1.equalsIgnoreCase(str2);


Chapter 5: Defining Classes II
Static methods and static variable
	Static method: Method that requires no calling object
	Definition:
		public static int maximum(int a, int b)
		{
			return a>b?a:b;
		}
	Invoke a static method:
		int budget = SomeClass.maximum(yourMoney, myMoney);

	Since static method does not need a calling object, it cannot refers to an instance
	variable of the class, nor can it invoke a nonstatic method of the class.

	Static variable: variable that belongs to the class as a whole and not just to one object
	Definition: 
		private static int turn;
	Note: 
		+ Good programming style dictates that static variables should normally be marked
		private unless they are marked final.
Math class:
	Math.round(double/float)
	Example:
		Math.round(3.2) => 3
		Math.round(3.6) => 4
	Math.ceil(double) : return the smallest whole number greater than or equal to the arg
	Example:
		Math.ceil(3.2) => 4
		Math.ceil(3.9) => 4
	Math.floor(double): return the largest whole number less than or equal to the arg
		Math.ceil(3.2) => 3
		Math.ceil(3.9) => 3
	Math.random(): 0 <= return < 1.0
Wrapper Classes:
	Definition:
		Integer intObj = new Integer(32);
	The process of going from a value of primitive type to an object of its wrapper class
	is sometimes called boxing. To go in the reverse direction, from an object of type Integer
	to the coressponding int value (unboxing):
		int i = intObj.intValue();
	The wrapper classes for primitive types Byte, Short, Long, Float, Double, Character
	
	Automatic Boxing and Unboxing
	The value of the primitive type  <=> private instance variable
	Automatic boxing:
		Integer num = 47;
		Double price = 123.5;
		Character grade = "A";
	Automatic unboxing:
		int numP = num;
		double priceP = price; 
	Example:
		Double price = 19.5;    <=> Double price = new Double(19.5);
		price = price + 5.2;    <=> price = new Double(price.doubleValue() + 5.2);
Static Methods in Wrapper Classes.	
The wrapper classes contain a number of useful constants and static method.
	- Largest and smallest values:
		+ Example: Integer.MAX_VALUE and Integer.MIN_VALUE
	- Parse method:convert back and forth between string representation of numbers
			and the coressponding number of type int.
		+ Example:  Double.parseDouble("199.98") => double 199.98;
			    Double.parseDouble(theString.trim()); // remove leading
									and trailing whitespace, such as blanks.
			    Double.toString(123.45) => String "123.45";

	-String method:
		+ "String".toLowerCase(); => "string";
		+ "String".charAt(0); => "S";
		+ "String".substring(1); =>"tring";


References and Class Parameters
Variables and Memory
	Note: Why Eight Bits:
		First, 8 is a power of 2. Since computers use bits, which have only two
		possible values, powers of 2 are more convenient than powers of 10.
		Second, it turns out that 7 bits are required to code a single character
		of the ASCII character set. So 8 bits(1 byte) is the smallest power of 2
		that will hold a single ASCII character.
	_________
byte0	|	|
	---------        variable1( 2byte location with address 0)	
byte1	|	|
	---------
byte2	|	|
	---------	 variable2(2byte location with address 2)
byte3	|	|
	---------


References
A variable of a class type stores only the memory address of where an object is located
The object named by the variable is stored in some other location in memory, an the variable
contains only the memory address of where the object is stored.

Class Parameters
Strictly speaking, all parameters in java are call-by-value.


The Constant null
null like a reference that does not refer to any object. Use '==' to test null object.

The new Operator and Anonymous Objects.
	+ Example: 
		if(var1.equals(new ToyClass("Joe", 42)))
			sys.out("Equal");
		else sys.out("Not Equal");
It is called anonymous because the object is not assigned a variable to serve as its name.

Using and Misusing References
Class Invariant:
	A statement that is always true for every object of the class is called a class invariant
	A class invariant can help to define a class in a consistent and organized way.


Copy Constructors
	Definition: is a constructor with a single argument of the same type as the class.
	Example: 
		Date date1 = new Date("January", 1, 2015);
		Date date2 = new Date(date1);
	A copy constructor should be designed so the object it creates is intuitively an exact
	copy of its parameter, but a completely independent copy.

Privacy Leaks:
	Leaking accessor methods:
		public Date getBirthDay()
		{
			return born;	//Date date = citizen.getBirthDay();
		}			//born.setDate("April", 1, 3000);
	Leaking mutator methods:
		public void setBirthDay(Date newDate)
		{
			born = newDate;	//Date date = new Date("April", 1, 3000) 
		}			//citizen.setBirthDay(date);
	
Mutable and Immutable Classes
	Immutable: A class that contains no methods that change any of the data in an object
		of the class is called an immutable class and objects of the class are called
		immutable objects. (Ex String)
	Mutable: A class that contains public mutator methods or other public methods, such as
		input method, that can change the data in an object of the class is called
		a mutable class, and objects of the class are called mutable objects.
	Note: Use should never write  a method that returns a mutable object, but should instead
		use a copy constructor to return a reference to a completely independent copy
		of the mutable object.
	
Deep Copy versus Shallow Copy
	return new object => deep copy;
	return object => shallow copy; 

Packages and javadoc
Packages and import Statements
	import statement
		Syntax: import Package_Name.Class;
	To make a package, group all the classes together into a single directory and add the package
	statement to the beginning of each class file:
		package Package_Name;
	CLASSPATH: 
		Example:

	-----libraries
		|----newlibraries
			|-----utilities
				|------numericstuff
					|-----Aclass.class
					|-----AnotherClass.class

 
			CLASSPATH: libraries/newlibraries
			package directory:libraries/newlibraries/utilities/numericstuff
			=> package utilities.numericstuff;
			=> import utilities.numericstuff.*;
The default package
	All the classes in your current directory belong to an unnamed package called the default 
	package. As long as the current directory is on your CLASSPATH, all the classes in the default
	package are automatically available to your code.(current directory CLASSPATH .;)
	CLASSPATH:  .;\libraries\newlibraries;\otherstuff\specialjava
Specifying a class Path when you compile:
	command: 
		+ javac -classpath .;C:/lib/numeric;C:/otherstuff YourClass.java
		+ java -classpath .;C:/lib/numeric;C:/otherstuff YourClass


Name Clash:
	Two classes have the same name.
	Solution: Use the fully qualified class names.
		apack.HighClass obj1 = new apack.HighClass();
		bpack.HighClass obj2 = new bpack.HighClass();



Introduction to javadoc
	- Encapsulation: Seperate the interface of a class ( the instructions on how to use the class) from the
		implementation ( the detailed code that tells the computer how the class does its work)
	- Commenting Classes for javadoc.
		Two condition:
			+ The comment must immediately precede a public class definition, a public method
			definition, or other public item.
			+ The comment must be a block comment(/*  */ comment), and the opening /* must contain 
			an extra *. So the comment must be marked by /** at the beginning and */ at the end.
 		// is not extract
		@tag the special information about parameters and so forth.
			Example:
				/**
				Tests for equality of two objects of type Person.
				@param otherPerson The person being compared to the calling object
				@return Return true if the calling object equals otherPerson
				*/
				public boolean equals(Person otherPerson)
		Some of the @tags
		@param	para_name para_description
		@return description_of_value_returned
		@throws Exception_Type Explaination
		@deprecated
		@see package_name.class_name
		@author Author
		@version Version_Information
Running javadoc
	command: javadoc -d Documentation_Directory Package_Name
	Example: javadoc -d documentation/mypackages mylibraries.numericstuff


Chapter 6: Array
Declaring and Creating an Array
	Syntax:
		Base_Type[] array_name = new Base_Type[Length];
	Example:
		char[] line = new char[10];
		Person[] specimen = new Person[100];
	Length of array: array.length
	Initializing arrays:
		int[] age = {2,12,1};
	TIP: char array to String:
		Example: char[] a = {'A', ' ','B','C','D','E'};
			String s = new String(a);
			String b = new String(a,2,3);

PITFALL: Arrays with a Class Base Type:
	Date[] holidayList = new Date[20];
	Note: It creates 20 indexed variables of type Date. This does not create 20 object of type Date.
	The index variables are automatically initialized to null.
	=> Date[] holidayList = new Date[20];
	   for(int i= 0; i< holidayList.length; i++)
		holidayList[i] = new Date();

Returning an Array:
Syntax:
	public [static] Base_Type[] method_name(para_list)
	{
		Base_Type[] temp = new Base_Type[Array_Size];
		return temp;
	}
For-Each loop for arrays:
	Syntax: 
		for(Array_Base_Type variable:array_name)
			statement

Chaper 7: Inheritance
A sample class hierarchy:
				    Employee
			________________|________________
			|				|
		HourlyEmployee			SalariedEmployee
		________|_______		_______|________
		|		|		|		|
	     FullTime	     PartTime      TechStaff         Executive
				________________|_______________		
				|		|		|
			    Engineer         Techician       ClericalStaff

	public class Employee{
		public Employee(){
			name = "No name";
			hireDate = new Date("April", 1, 1000);
		}
		public Employee(Employee aEmployee){
			name = aEmployee.name;
			hireDate = new Date(aEmployee.hireDate);
		}
	}
	public class HourlyEmployee extends Employee{
		public HourlyEmployee(){
			super();
			wageRate = 0;
		}
		public HourlyEmployee(HourlyEmployee aHourlyEmployee){
			super(aHourlyEmployee);
			wageRate = aHourlyEmployee.wageRate;
		}

	} 

The derived class inherits all the public methods, all the public and private instance variable
, and all the public and private static variables from the base class, and it can add more instance
variables, more static variables, and more methods.

Overriding a method definition
If you add the modifier final to the definition of a method, it indicates that the method may not be redefined
in a derived class.

Changing the return type of an overriddden method
You may not change the type returned by the method. One exception, if the returned type is a class type, then
you may change the returned type to that of any descendent class of the return type. (covariant return type)
	Example:
		public Employee getSomeone(int someKey) // In base class
		public HourlyEmployee getSomeone(int someKey) // In derived class
		=> HourlyEmployee is an Employee

Change the access permission of an overridden method.
In way that make access permissions more permissive.

The super Constructor
	super(): call to the constructor for base class.
Note: If a constructor definition for a derived class does not include an invocation of a constructor for the
	base class, then the no-argument constructor of the base class is invoked automatically as the first action
	of the derived class constructor.

The this Constructor
You keyword this to invoke a constructor in the same class.
Example:
	public HourlyEmployee()
	{
		this("No name", new Date("April", 1, 1000), 0, 0);
	}

	public HourlyEmployee(String theName, Date theDate, double theWageRate, double theHours)


An object of a derived class has the type of the derived class, and it also has the type of the base class.
More generally, a derived class has the type of every one of its ancestor classes. So, you can assign an object
of a derived class to a variable of any ancestor type. You can plug in a derived class object for a parameter 
of any of its ancestor type. You can use a derived class object anyplace you can use an object of any of its 
ancestor types.
 
Encapsulation and Inheritance
An instance variable or method that is private in a base class is not accessible by name in the definition 
of a method in any other class, not even in a method definition of a derived class.
The instance variables name and hireDate are private instance variables in the class Employee, and although
a derived class HourlyEmployee inherits these instance variables, it cannot access them directly. You must instead
use public accessor and mutator methods (such as getName and setName) that were defined in the base class.


Protected and Package Access
protected method or instance variable can be accessed by name inside its own class definition, by name inside any class
derived from it, and by name in the definition of any class in the same package.

package access method or instance variable can be accessed by name inside the definition of any class in the same package
but not outside of the package.

Programming with Inheritance.

	"is a" versus "has a":

		+ The object of the derived class HourlyEmployee is also an instance of the class Employee => an HourlyEmployee
		is an Employee. This is an example of the "is-a" relationship between class.

		+ The class Employee defined earlier has an instance variable of the class type 
		Date. => Employee "has a" Date (composition)

		=> HourlyEmployee is an Employee and has a Date.

Access to a Redefined Base Method.

	Example: 	public String toString() //HourlyEmployee
			{
				return (getName() + " " + getHireDate().toString()
					+ "\n$" + wageRate);
			}
			
			public String toString() //Employee
			{
				return (name + " " + hireDate.toString());
			}

			public String toString()
			{
				return (super.toString() + "\n$" wageRate);

The Class Object
	- In Java, every class is an descendent of the class Object. So, every object of every class is of type Object, as well 
	as being of the type of its class.

The Right Way to Define equals
	- The heading for the the method equals in the class Object:
		+ public boolean equals(Object otherObject);

	- equals method:
		public boolean equals(Object otherObject)
		{
			Employee otherEmployee = (Employee) otherObject;
			return (name.equals(otherEmployee.name) && hireDate.equals(otherEmployee.hireDate));			

		}
	- We needed to type cast the para otherObject from type Object to type Employee. If we omit the type cast
	otherObject.name --> error because the class Object does not have an instance variable named name.

	- Every object inherits the method getClass() from the class Object (final):
		Example: o = new Employee();
			 o.getClass() => Employee.
			
		if (obj1.getClass() == obj2.getClass()) // this.getClass() == obj.getClass()
			Sys.out("Same class");
		else
			Sys.out("Not same");

TIP: getClass versus instanceof:
	- instanceof operator checks to see if an object is of the type given as its second argument:
	Syntax: Object instanceof Class_Name
	VS:
		public boolean equals(Object otherObject) //Employee
		{
			if(!(otherObject instanceof Employee))
				return false
			else
			{
				Employee otherEmployee = (Employee) otherObject;
				return (name.equals(otherEmployee.name) && hireDate.equals(otherEmployee.hireDate));			
			}
		}
		
		public boolean equals(Object otherObject)
		{
			if(!(otherObject instanceof HourlyEmployee))
				return false
			else
			{
				HourlyEmployee otherHourlyEmployee = (HourlyEmployee) otherObject;
				return (super.equals(otherHourlyEmployee) && (wageRate == otherHourlyEmployee.wageRate);
			}


		}

		Employee e = new Employee("Joe" , new Date("Jan", 1, 1000));
		HourlyEmployee hourlyE = new HourlyEmployee("Joe", new Date("Jan", 1, 1000), 50.50);
		

		e.equals(hourlyE) => true
		hourlyE.equals(e) => false //because e is an Employee but e is not an HourlyEmployee

		
		
Chapter 8: Polymorphism and Abstract Classes

Polymorphism
	- Binding refers to the process of associating a method definition with a method invocation. If the method
	definition is associated with the method invocation when the code is compiled, that is called early binding.
	If the method definition is associated with the method invocation when the method is invoked (at run time),
	that is called late binding or dynamic binding. => Java use late binding for all methods except for a few cases.

	https://stackoverflow.com/questions/19017258/static-vs-dynamic-binding-in-java
	- Early Binding: just looks at the type(what ever is before the equals so it will be seen as just a collection
	object when in fact it is a hashSet. Dynamic Binding take into account the actual object ( what after the equal
	so it actually recognises it is a hashSet).


	- Polymorphism: polymorphism and late binding are essentially just different words for the same concept. Polymorphism
	refers to the processes of assigning multiple meanings to the same method name using late binding.
	- The final Modifier
	If you add the modifier final to the definition of a method, it indicates that the method may not be redefined in a derived
	class. If you add the modifier final to the definition of a class, it indicates that the class may not be used as a base class
	to derive other classes.
	
Sale Records Example	
Late Binding with toString

	public void println(Object theObject)
	{
		System.out.println(theObject.toString());
	}

	The invocation of the method println inside the braces is a different, overloaded definition of the method println. That invocation
	inside the braces uses a method println that has a parameter of type String, not a parameter of type Object.


PITFALL: No Late Binding for Static methods:
	Javas does not use late binding with prive methods. methods marked final or static methods.
	With static binding, the decision of which definition of a method to use with a calling object is made at compile time based on the type
	of the variable naming the object.
	public static void announcement() { Sys.out("Sale Class"); } // Sale class
	public static void announcement() { Sys.out("Discount Class);} //Discount Class
	public void showAdvertisment()
	{
		announcement(); //in Sale class and not override in the class Discount
	}
	
	If you invoke a static method within the definition of a nonstatic method but without any class name or calling object, then the calling object
	is an implicit this, which is a calling object.
		
	Sale a = new Sale("Cap", 10.00);
	DiscountSale discount = new DiscountSale("Cap", 11.00, 10);
	a.showAdvertisment();
	discount.showAdvertisment();

	=> result

	Sale class
	Cap price and total: 10$
	Sale class                                // instead of Discount class.
	Cap price = 11.00 discount 10% total 9.9$

	=> Compile time (based on the type of the variable holding the calling object

Note 528 not understand.


Downcasting and Upcasting

	DiscountSale discount = new DiscountSale();
	Sale aDiscount = discount;
	aDiscount.announcement(); => static binding => type Sale => "Sale Class."
	aDiscount.toString(); => dynamic binding => type Discount => "paint Price = $15.0 Discount = 10.0% Total cost = $13.5"

Note: The type of the variable naming an object determines which method names can be used in an invocation with that calling object. However, the object itself always
	determines the meaning of the method invocation performed by an object => late binding. The type of a class parameter determines which method names can be used 
	with the parameter, but the argument determines which definition of the method name is used.


	up casting: assigning an object of derived class to a variable of a base class (or any ancestor class).
	downcasting: (more trouble) Doing a type cast from a base case to a derived class ( or from any ancestor class to any descendent class).

	Example:
		Sale sale = new Sale("paint", 15);
		DiscountSale discount;
		discount = (DiscountSale) sale; //error
	does not make sense because the object named by sale has no instance variable named discount
	and so cannot be an object of type DiscountSale. Every DiscountSale if a Sale but note every Sale
	is a DiscountSale. => Use downcasting only in situation where it makes sense.

		discount = (DiscountSale) sale; // run-time error but compile with no error
		discount = saleVariable; //compile-time error illegal

	Legal downcasting:
		Sale otherSale = (Sale) otherObject;

TIP: Checking to See Whether Downcasting Is Legitimate
	Use instanceof operator to test whether or not downcasting is sensible.
	Downcasting to a specific type is reasonable if the object being cast is an instance 
	of the type, which is exactly what the instanceof operator tests for.
 	Syntax: Object instanceof Class_name
	
	Example:
		DiscountSale ds = new DiscountSale();
		if(someObj instanceof DiscountSale)
		{
			ds = (DiscountSale) someObj;
		}

clone Method
	The clone method has no parameters and should return a copy of the calling object. (deep copy)
	Syntax:
		protected Object clone()
	Example: Use the copy constructor to create the copy returned by clone method.
		public Sale clone() //covariant return type protected => public
		{ 
			return new Sale(this);
		}
	
PITFALL: Sometimes the clone method return type is Object
	Prior to version 5.0, Java did not allow covariant return types => clone method will have return type of
	Object => type cast on the value returned by clone.
	Example:
		OldClass copy = (OldClass) original.clone();
	When in dount about the clone method of a class, include the type cast.


PITFALL: Limitations of Copy Constructors

	Problem:
		public static Sale[] badCopy(Sale[] a)
		{
			Sale[] b = new Sale(a.length);
			for (int i= 0; i< a.length; i++)
				b[i] = new Sale(a[i]); //problem here
			return b;
		}
	If array a contains objects from derived classes of Sale (DiscountSale), then badCopy(a) will not return a
	true copy of a. Every element of the array badCopy(a) will be a plain old Sale, because the Sale copy constructor
	produces only plain old Sale; no element in badCopy(a) will be an instance of the class DiscountSale.
	
	=> Use the method clone, things work out as they should. Because of late binding (polymorphism), a[i] always means the
	correct version of the clone method.
		for (int i= 0; i< a.length; i++)
		{
			b[i] = a[i].clone();
		}
	
	The copy constructors named Sale and DiscountSale have different names, and polymorphism has nothing to do with methods
	of different names.
	
Abstract class
	Abstract class is a class that has some methods without complete definition. Cann't create an object using abstract class constructor,
	but can use an abstract class as a base class to define a derived class.
	
	Example:
		Suppose that when we define the class Employee, we might add the samePay method to the class Employee to compare employees to see
		if they have the same pay.
			public boolean samePay(Employee other)
			{
				return (this.getPay() == other.getPay());
			}
		Problem:
			1. The method samePay includes an invocation of the method getPay, and the class Employee has no getPay method.
			2. There is no reasonable definition we might give for a getPay method so that we could add it to the class Employee.
		=> Because the Employee have no information abour pay.
		Every real-world employee does have some pay ( belong to HourlyEmployee or SalariedEmployee), and the two derived classes each 
		have a getPay method. The problem is that we do not know how to define the getPay method util we know if the employee is an hourly
		or salaried. We would like to post the definition of the getPay method and give it only in each derived class of the Employee class.
		=> abstract method:
			public abstract double getPay();

	An abstract method can be thought of as the interface part of a method with the implementation details omitted. In java abstract method cannot be
	private because a private method is normally only a helping method and so not part of the interface for a programmer using class => it does not make
	sense to have a private abstract method. Normally abstract method is public but protected and package (default) access is allowed.
	
	An abstract emthod serves as a placeholder for a method that must be defined in all (nonabstract) derived classes.

	Abstract class is a class that have at least one abstract method. >< concrete class
	
PITFALL: Cannot create instances of an abstract class.

TIP: An abstract class is a type
+ You cannot create an object of an abstract class. Nonetheless, it makes perfectly good sense to have a parameter of an abstract class type
such as Employee. Then, an object of any of the descendent classes of Employee can be plugged in for the parameter. It even makes sense to have a variable
of an abstract class type such as Employee, although it can only name objects of its concrete descendent classes.


Chapter 9: Exception Handling

Exception Handling Basics

try-catch Mechanism:
	When an exception is thrown, the code in the surrounding try block stops executing and another portion of code known as a catch block, begins execution.
	The catch block has a parameter, and the exception object thrown is plugged in for this catch block parameter.
	Example:
		trr{

		   }catch(Exception e)
			{
				String message = e.getMessage();
				System.out.println(message);
				System.exit(0);
			}
	catch block parameter: Each catch block can have at most one catch block parameter
		+ Exception_Class e: Exception_Class specifies what type of thrown exception object the catch block can catch. If the name is Exception, then the
					block can catch any exception.
		 
	Two possible cases of what can happen when a try block is executed:
		1. No exeption is thrown, the code in the try block is executed to the end of the try block, the catch block is skipped, and execution continues
			with the code placed after the catch block.
		2. Exception is thrown, the rest of the code in the try block is skipped, and the code in the catch block is executed and then the code that follows that
			catch block is executed.

Exception Handling with the Scanner Class

TIP: Exception Controlled Loops

	Sometimes when an exception is thrown you might want your code to simply repeat some code so that the user can get things right on a second or subsequent try:
		
		boolean done = false;
		while (!done)
		{
			try
			{
				//Code that may throw an exception in the class Exception_Class
				done = true;		
				//Possible more code
			}
			catch(Exception_Class e)
			{
				<Some code>
			}
	
		}

	Example:
		import java.util.Scanner;
		import java.util.InputMismatchException;

		public class InputMismatchExceptionDemo
		{
			public static void main(String[] args)
			{
				Scanner keyboard = new Scanner(System.in);
				int numer = 0;
				boolean done = false;
				while(!done)
				{
					try
					{
						number = keyboard.nextInt();
						done = true;
					}
					catch(InputMismatchException e)
					{
						keyboard.nextLine();
						System.out.println("Not a correctly written whole number");
						Ssytem.out.println("Try again");
					}
							
				}
				System.out.println("Your number " +number); 
			}

		}

Throwing Exceptions
	Format: throw new Exception(string_describing_the_exception);
	Example:
		try{
			if (a> b) throw new Exception("a cannot greater than b");
		}
	getMessage method: Every exception has a String instance variable that contains some message, which typically
			identifies the reason for the exeception.
		Example: throw new Exception(String_arg);
			The string_args given as an argument to the constructor Exception is used as the value of this String
			instance variable.



Exception Class
	All the exception classes in the Java libraries and the exception classes you define should have:
		+ There is a constructor that takes a single argument of type String.
		+ The class has an accessor method getMessage() that can recover the string given as an argument to 
		the constructor when the exception object was created.



Exception Classes from Standard Packages

Defining Exception Classes

	Example:
		public class DivisionByZeroException extends Exception
		{
			public DivisionByZeroException()
			{
				super("Division by Zero);
			}
			
			public DivisionByZeroException(String message)
			{
				super(message);
			}
		}


TIP: An Exception Class can carray a message of any type

	Example:
		public class BadNumberException extends Exception{
			private int badNumber;
			public BadNumberException(int number)
			{
				super("Bad number exception");
				badNumber = number;
			}		
			
			public BadNumberException()
			{
				super("Bad number exception");
			}

			public BadNumberException(String message)
			{
				super(message);
			}
			
			public int getBadNumber()
			{
				return badNumber;
			}
		}



Multiple catch Blocks

PITFALL: Catch the more specific Exception First
	When catching multiple exceptions, the order of the catch blocks can be important.
	Example:
		catch (Exception e)
		{
		...
		}
		catch (NegativeNumberException e)
		{
		...
		}
		=> The catch block for NegativeNumberException would never be used, because all exceptions are caught
		by the first catch block.

Throwing Exceptions in methods
		Example:
			public class Demo{
				public static void main(String[] args){
					int a = 5;
					int b = 6;
					try{
						double quotient = safeDivide(a,b);
					}catch(DivisionByZeroException e)
					{
						Sys.out(e.getMessage);
					}
						

				}

				public static double safeDivive(int a, int b) throws DivisionByZeroException{
					if(b == 0)
						throw new DivisionByZeroException("Divide by zero");
					double quotient = a/(double) b;
					return quotient;
					
				}	

			}

Declaring Exceptions in a throws Clause

	- public void sampleMethod() throws DivisionByZeroException; 
	=> declaring the exception. The method that might throw a DVSBZE and that
	not catch the exception would have a heading similar to 

	It warn programmer that any invocation of the method might possibly throw an exception.

	If there is more than one possible exception:
	- public void sampleMethod() throws AException, BException;
	
	When an exception is thrown in a method but not caught in that method, that immediatly ends the emthod invocation.



Exceptions to the Catch or Declare Rule

			    *Throwable
			________|________
			|		|		* checked exception
		    *Exception	      Error
			|
		*RuntimeException



	+ Exception that are descendents of the class RuntimeException do not need to be accounted for in a catch block or throws clause.
	+ Error object: Are not required to account for Error objects in a catch block or throws clause. 


- Exception classes that follow the Catch or Declare Rule are often called checked exceptions. Because the compiler checks to see if they
accounted for with a catch block or throws clause.
- Exception that are exempt from the Catch or Declare Rule are often called unchecked exceptions.

throws Clause in Derived Classes:
	When override a method definition in a derived class, it should have the same exception classes listed in its throws clause that it had
	in the base class or it should have a throws clause whose exceptions are a subset of those in the base class throws clause.

When to Use Exceptions
	In most case, you should include any throw statement within a method definition, list the exception class in a throws clause for that method
	and place the try catch blocks in a different method.

Note: Exceptions should be reserved for situations where a method has an exceptional case
and individual invocations of the method would handle the exceptional case differently. 


Event-Driven Programming
	- Exception is a example of a programming methodology known as event-driven programming. With event-driven programming, objects are defined
	so that they send events, which are themselves objects, to other objects that handle the event. Sending the event is called firing the event.

	- In exception handling, the event objects are the exception objects. They are fired (thrown) by an object when the object invokes a method 
	that throws the exception. An exception event is sent to a catch block, where it is handled.

More Programming Techniques for Exception Handling.

PITFALL: Nested try-catch Blocks
	- You can place a try-catch inside a larger try block or inside a larger catch block. But it is almost always better to place the inner try catch
	blocks inside a method definition and place an invocation of the method in outer try or catch block.
	- If place try-catch block inside a larger catch block, you will need to use different names for for the catch block parameter in the inner and outter
	blocks.
	- If you place a try-catch block inside a larger try block, and an exception is thrown in the inner try block but it not caught in the inner catch blocks
	then the exception is thrown to the outer try block for processing and might be caught in one of its catch blocks.


The finally Block
	- Contains code to be executed whether or not an exception is thrown in a try block.
	Syntax:
		try{}
		catch (Exception a){}
		catch (Exception b){}
		finally{}
	- There are three possibilities:
		+ No exception is thrown: try{} --> finally{}
		+ Exception is thrown and is caught in the catch block: try{} --> catch{} --> finally{}
		+ Exception is thrown and there is no matching catch: try{} --> finally{} --> method end. 
Rethowing an Exception:
	- A catch block can contain code that throws an exception. In some case, depending on the string produced by getMessage() or sth else, decide to throw the same
	or a different exception for handing further up the chain of exception handling blocks.

The AssertionError Class
	- assert operator: if your program contains an assertion check and the assertion check failts, your program will end will an error message. The object of the class
	AssertionError is thrown. if it is not caught in a catch block, your program ends with an error message.

ArrayIndexOutOfBoundsException
	AIOOBE is a descendent of the class RuntimeException and so need not be caught or accounted for in a throws clause.



Chapter 10: File I/O

Streams
	- A streams is a flow of data. If the date flows into your programs, then the stream is called an input stream. If the data flows out of your program, the stream is called
	an output stream.

Text Files
	- Writing to a Text File: The class PrintWriter is the preferred stream class for writing to a text file.
	- All the file I/O-related classes are in the package java.io.
	Example:
		outputStream = new PrintWriter(new FileOutputStream("stuff.txt")); //connect the stream named outputStream to the file named stuff.txt (opening the file)
	Note: The class PrintWriter has no constructor that takes a file name as its argument => Use class FileOutputStream to create a stream that can be used as an argument
		to a PrintWriter constructor.

		
	Example: Sending Output to a Text File
	/*
		import java.io.PrintWritter;
		import java.io.FileOutputStream;
		import java.io.FileNotFoundException;

		public class TextFileOutputDemo{
			public static void main(String[] args){
				PrintWriter outputStream = null // define outside of the try block so that this var can be used outside of the try block.
				try{
					outputStream = new PrintWriter(new FileOutputStream("stuff.txt")); // only place that an exception might be thrown.
				}
				catch(FileNotFoundException e)
				{
					System.out.println("Error opening the stuff.txt file");
					System.exit(0);	
				}
				//write to file
				outputStream.println("The quick brown fox");
				outputStream.println("jumps over the lazy dog");
				outputStram.close();
			}

		}
		
	- A File has two names: (1) the real file name that is used by the operating system and (2) the name of the stream that is connected to the file.
				The stream nam serves as a temporary name for the file and is the name that is primarily used within your program.

	Note: A FileNotFoundException does not mean that the file was not found. In this case, it actually means that the file could not be created (for example, because
		the file name is already used for a directory (folder) name.
	
Some methods of the class PrintWriter

	- public PrintWriter (OutputStream streamObject)
		- Use file name: new PrintWriter(new FileOutputStream(File_Name));
		=> A blank file is create. If there already is a file named File_Name, then the old contents of the file are lost. 
		If you want instead to append new text to the end of the old file content:
			+ new PrintWriter(new FileOutputStream(File_Name, true));
		* When used in  either of these ways, the FileOutputStream constructor, and so the PrintWriter constructor invocation, can throw a FileNotFoundException.

	- public void println(Argument);
		- Argument can be string, integer ...boolean or any combination of these, connectd with + signs. The Arg can also be any object, although it not work as desired
		unless the object has a properly defined toString() method.

	- public void print(Argument);
		- This is the same as println, except that this method does not end the line, so the next output will be on the same line.

	- public PrintWriter printf(Argument);
		- Sends output to the text file. It return the calling object. However, we have always used printf as a void method.

	- public void close();
		- Close the stream's connection to the file. The following method calls flush before closing the file:
	
	- public void flush();
		- Flush the output stream. This forces an actual physical write to the file ofany data that has been buffered and not yet physically written to the file. Normally, you should
		not need to invoke flush.

You should close the close files with an explicit call to the method close. Because:
	1. If your program ends abnormally, then Java may not be able to close the file for you. This could damage the file. If it is an output file, any buffered output will not have been
	physically written to the file. So, the file will be incomplete. The sooner you close a file, the less likely it is that this will happen.
	2. If your program writes to a file and later reads from the same file, it must close the file after it is through writting to the file and then reopen the file for reading.

PITFALL: Overwriting an output file
	+ PrintWriter outputStream = new PrintWriter(new FileOutputStream("stuff.txt"));
	Note: If there is no file named stuff.txt, this will create an empty file named stuff.txt. If a file named stuff.txt already exists, then this will eliminate that file and create a new, empty
	file named stuff.txt. So if there is a file named stuff.txt before this file opening, then all the data in that file will be lost.

Appending to a Text File
	+ PrintWriter outputStream = new PrintWriter(new FileOutputStream("stuff.txt", true);
	Note: If the file stuff.txt is not exist, Java will create an empty file and append the output to the end of this empty file. However, if the file stuff.txt already exists, then the old contents will
	remain, and the program's output will be placed after the old contents of the file. (try-catch block);

TIP: toString helps with text file output
Both print and println of the class PrintWriter can take any object as an argument and will produce reasonable output so long as the object has a sensible toString() method.

Reading from a Text File

Reading a text file using Scanner
	Example: Create a stream of the class Scanner and connect it to a text file for reading
		Scanner inputStream = null;
		inpurStream = new Scanner(new FileInputStream("stuff.txt"));
	After this statement, you can use the methods nextInt, nextLine, and so forth to read from the named text files.
	When used in this way, the FileInputStream constructor, and hence the Scanner constructor invocation, can throw a FileNotFoundException.


	Example:
		Scanner inputStream = null;
		try
		{
			inputStream = new Scanner(new FileOutputStream("stuff.txt"));
		}
		catch(FileNotFoundException e)
		{
			Sys.out("File not found");
			Sys.exit()
		}
		int n1 = inputStream.nextInt();
		int n2 = inputStream.nextInt();
		int n3 = inputStream.nextInt();
		
		inputStream.nextLine();
		
		String line = inputStream.nextLine();

		Sys.out(n1 + ", " + n2 +" and " +n3);
		Sys.out("Line: " + line);	// to go to the next line

		inputStream.close();
		
		stuff.txt			Program output
		_________________________________________________
		-----------------	
		|1 2		|       => 	1,2 and 3
		|3 4		|		Line: Eat my shorts.
		|Eat my shorts.	|
		-----------------

Testing for the End of a text file with Scanner

	- You can use the method like nextInt or nextLine that throws NoSuchElementException when the input is not a correctly formed to check the end of input.
	However, each of the input methods has corresponding method (such hasNextInt) that checks to see if there is any more wekk-formed input of the appropriate
	type. The nice thing about these method is that they report when there is not a suitable next token for any reason; they do not check only for the end of a file
	

Note:	-----------------
	|File data.txt	|	
	|1 2		|
	|3 4 hi 5	|--> Reading ends when either the end of the file is reached or a token that is not an int is reached. So, the 5 is never reached.
	-----------------
	int next, sum = 0;
	while (inputStream.hasNextInt())
	{
		next = inputStream.nextInt();
		sum = sum + next;
	}
	inputStream.close();
	Sys.out("Sum = " +sum); ==> Output: Sum = 10;


Some of the methods in the Scanner class:
	- public Scanner(InputStream streamObject)
	- new Scanner(new FileInputStream(File_name))
	- public Scanner(File fileObject)
		+ If you want to create a stream using a file name, you can use:
			new Scanner(new File(File_name))
	- public int nextInt(): return a next token as an int, provided the next token is a well-formaed string representation of an int.
		+ Throws a NoSuchElementException if there are no more tokens.
		+ Throws an InputMismatchException if the next token is not well-formed string representation of an int.
		+ Throw an IllegalStateException if the Scanner stream is closed.
	- public boolean hasNextInt(): return true if the next token is a well-formed string representation of an int; otherwise returns false.
		+ Throw an IllegalStateException if the Scanner stream is closed.

	- public long nextLong();
	- public boolean hasNextLong();
	- public byte nextByte();
	- public boolean hasNextByte();
	- public short nextShort();
	- public boolean hasNextShort();
	- public double nextDouble();
	- public boolean hasNextDouble();
	- public float nextByte();
	- public boolean hasNextFloat();

	- public String next(); Return the next token.
	- public boolean hasNext(); Return true if there is another token. May wait for a next token to enter the stream.

	- public String nextLine(); Returns the rest of the current line. Note that the line terminator '\n' is read and discarded.
	- public boolean hasNextLine(); Return true if there is another token. May wait for a next line to enter the stream.

	- public Scanner useDelimiter(String newDelimiter); Changes the delimiter for input so that newDelimiter will be the only delimiter that
	seperates words or number. Returns the calling object, but we have always used it as a void method.


Unchecked Exceptions:
	NoSuchElementException, InputMismatchException, IllegalStateException are all unchecked exceptions.

Page 635;

